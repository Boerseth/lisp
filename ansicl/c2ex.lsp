(load "headers.lsp")
(section 2 "" "Exercises")
(exercise "1." "
Describe what happens when the following expressions are evaluated:")
(exercise "[a]" "(+ (- 5 1) (+ 3 7))")
(answer "The inner parens evaluate to 4 and 10, and the outer to 14:")
(+ (- 5 1) (+ 3 7))
(done)

(exercise "[b]" "(list 1 (+ 2 3))")
(answer "After the inner paren evals to 5, the outer becomes a list of 1 and 5")
(list 1 (+ 2 3))
(done)

(exercise "[c]" "(if (listp 1) (+ 1 2) (+ 3 4))")
(answer "It returns a 7")
(if (listp 1) (+ 1 2) (+ 3 4))
(done)

(exercise "[d]" "(list (and (listp 3) t) (+ 1 2))")
(answer "It returns a list of NIL and 3")
(list (and (listp 3) t) (+ 1 2))
(ddone)


(exercise "2." "Give three distinct cons expressions that return (a b c).")
(cons 'a '(b c))
(cons 'a (cons 'b '(c)))
(cons 'a (cons 'b (cons 'c ())))
(ddone)


(exercise "3." "Using car and cdr, define a function to return the fourth element of a list.")
(defun my-fourth (lst)
  (car (cdr (cdr (cdr lst)))))
(my-fourth '(a b c d))
(ddone)


(exercise "4." "Define a function that takes two arguments and returns the greater of the two.")
(defun greater (x y)
  (if (or (numberp x) (numberp y))
    (if (and (numberp x) (numberp y))
      (if (> x y) x y)
      (if (numberp x) x y))
    nil))
(greater 5 6)
(greater 6 6)
(greater 7 6)
(greater 'a 6)
(greater 7 'a)
(greater 7 ())
(greater 7 '(a b))
(ddone)


(exercise "5." "What do these functions do?")
(exercise "[a]" "")
(defun enigma (x)
  (and (not (null x))
       (or (null (car x))
           (enigma (cdr x)))))
(answer "It checks whether any element in x is NIL")
(enigma '(1 2 3))
(enigma '(nil 2 3))
(enigma '(1 2 3 nil 2 3))
(enigma '(1 2 3 2 3 nil))
(enigma nil)
(done)

(exercise "[b]" "")
(defun mystery (x y)
  (if (null y)
    nil
    (if (eql (car y) x)
      0
      (let ((z (mystery x (cdr y))))
        (and z (+ z 1))))))
(answer "It finds the position of x as element in list y")
(mystery 5 '(1 2 3 4 5 6))
(mystery 'c '(a b c d))
(mystery 3 '(a b c d))
(mystery 1 nil)
(ddone)


(exercise "6." "What could occur in place of the x in each of the following exchanges?")
(exercise "[a]" "(car (x (cdr '(a (b c) d))))  =>  B")
(car (first (cdr '(a (b c) d))))
(done)

(exercise "[b]" "(x 13 (/ 1 0))  =>  13")
(or 13 (/ 1 0))
(done)

(exercise "[c]" "(x #'list 1 nil)  =>  (1)")
(apply #'list 1 nil)
(ddone)


(exercise "7" "Using only operators introduced in this chapter, define a function that takes a list as an argument and returns true if one of its elements is a list")
(defun contains-list (lst)
  (if (null lst)
    nil
    (if (listp (car lst))
      t
      (contains-list (cdr lst)))))
(contains-list '(a b c))
(contains-list '(a b c '(1 2)))
(contains-list nil)
(contains-list '('(1 2)))
(ddone)


(exercise "8." "Give iterative and recursive definitions of a function that")
(exercise "[a]" "takes a positive integer an prints that many dots.")
(defun iter-dots (n)
  (do ((i 0 (+ i 1)))
    ((eql i n))
    (format t ".")))
(defun rec-dots (n)
  (if (> n 0)
    (format t "."))
  (if (> (- n 1) 0)
    (rec-dots (- n 1))))
(iter-dots 4)
(rec-dots 4)
(done)

(exercise "[b]" "takes a list and returns the number of times the symbol a occurs in it.")
(defun iter-a-count (lst)
  (let ((i 0))
    (dolist (obj lst)
      (if (eql 'a obj)
        (setf i (+ i 1))))
    i))
(defun rec-a-count (lst)
  (if (null lst)
    0
    (if (eql 'a (car lst))
      (+ 1 (rec-a-count (cdr lst)))
      (rec-a-count (cdr lst)))))
(iter-a-count '(a a b a b b a))
(rec-a-count '(a a b a b b a))
(ddone)


(exercise "9." "A friend is trying to write a function that returns the sum of all the non-nil elements in a list. He has written two versions of this function, and neither of them work. Explain what's wrong with each, and give a correct version:")
(exercise "[a]" "
(defun summit (lst)
  (remove nil lst)
  (apply #'+ lst))
")
(answer "The problem is that `remove` does not alter the contents of `lst`. It only returns a new list, which is the same as `lst` only with `nil` removed. To fix this, make the `apply` act on the return of the first paren:")
(defun summit (lst)
  (apply #'+ (remove nil lst)))
(summit '(1 2 3 4 () 5 6 () 7 8 9))
(done)

(exercise "[b]" "
(defun summit (lst)
  (let ((x (car lst)))
    (if (null x)
      (summit (cdr lst))
      (+ x (summit (cdr lst))))))
")
(answer "Here, the issue is that once in the recursion process `lst` is empty, we end up in an infinite recursion. Both (car ()) and (cdr ()) return NIL, so that the second to last line is called over and over again.")
(defun summit (lst)
  (if (null lst)
    0
    (if (null (car lst))
      (summit (cdr lst))
      (+ (car lst) (summit (cdr lst))))))
(summit '(1 2 3 4 () 5 6 () 7 8 9))
